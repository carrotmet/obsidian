Go语言标准库中的`sync`包提供了几种并发安全的容器，它们可以用于在多个协程之间安全地共享数据。以下是一些常见的并发安全容器：

1. **sync.Map**
   - 一个并发安全的Map实现，允许多个协程安全地读写同一个Map。

2. **sync.Pool**
   - 一个可以存储和复用临时对象的容器，有助于减少垃圾回收的压力。它允许你设置最大容量，并在达到这个容量时回收旧的对象。

3. **sync.Mutex**
   - 互斥锁，用于保护对共享资源的访问，确保同一时间只有一个协程可以访问受保护的资源。

4. **sync.RWMutex**
   - 读写互斥锁，允许多个协程同时读取资源，但在写入时会锁定资源，阻止其他协程的读写访问。

5. **sync.Once**
   - 确保初始化操作（比如函数调用）只执行一次，常用于全局变量的初始化。

6. **sync.WaitGroup**
   - 用于等待一组协程完成。它通过计数器来跟踪协程的数量，并通过调用`Done`方法来减少计数，调用`Wait`方法阻塞直到计数器为零。

7. **sync.Cond**
   - 条件变量，用于在多个协程之间同步条件，允许一个协程等待另一个协程发出信号。

8. **sync.Locker**
   - 一个接口，任何实现了`Lock`和`Unlock`方法的类型都可以作为互斥锁使用。

9. **sync. RWMutex 是 sync.Locker 的实现**
   - 这意味着`sync.RWMutex`可以作为实现了`Locker`接口的锁使用。

10. **sync.NewCond**
    - 创建一个新的条件变量，需要与`sync.RWMutex`或`sync.Mutex`一起使用。

这些容器和同步原语提供了强大的工具，帮助开发者编写并发程序，同时避免常见的并发问题，如死锁、竞态条件等。使用这些工具，你可以构建出既安全又高效的并发应用程序。

请注意，虽然`sync.Map`、`sync.Pool`、`sync.Mutex`、`sync.RWMutex`等是并发安全的，但它们并不是用来替代基本的Go容器类型（如`map`、`slice`等）的。它们主要用于在需要并发控制的场景下，提供线程安全的操作。在单线程或无需并发控制的情况下，使用基本的Go容器类型通常是更简单且效率更高的选择。