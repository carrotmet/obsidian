- 并发与并行
	- 并发描述有多个线程模拟同时执行一段程序 （用锁保障、时间分片、模拟并行）--- 单处理器上线程微观串行、宏观并行（在商用服务器，比如数据系统常用---高并发）（逻辑层面）——**时间片轮转**
	- 并行是这多个线程将真正同时执行这段程序 （线程间互不干扰，由多核cpu的多个核执行）（物理层面）
- 线程与进程
	- 线程是cpu调度的最小单位
	- 进程是进行资源分配和调度的基本单位
	- 操作系统包括：cpu、内存、硬盘
- 堆、栈空间
	- 每个进程有独立堆空间、有进程栈空间
	- 每个线程有存储自己局部变量与上下文的栈空间 ---  没有自己的堆空间
	- 栈空间用于处理线程与进程的上下文（时间层面）
	- 堆空间用于处理进程中各个线程的动态内存以及进程所属的全局变量（物理层面、空间层面）

- 同步与异步
	- 同步——依赖，不能并行
	- 异步——可并行
- 同步/阻塞表格
	- 同步-

- concurrency编程（锁、通知、线程安全、错误处理、高性能）
	- 并发编程的本质在于管理多个执行流（如线程或协程）对共享资源的访问和协调，以确保数据的一致性和系统的响应性。
	- 并发数据结构（并发队列、原子变量）
    - 核心挑战：如何在并发环境确保操作的顺序性欲一致性
```C++
#include <iostream>
#include <mutex>
#include <condition_variable>
#include <thread>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;   //共享全局变量用来控制线程启动

void printLetters() {
    for (char ch = 'A'; ch <= 'Z'; ++ch) {
        std::unique_lock<std::mutex> lock(mtx);
        ready = true;
        cv.notify_one();
        cv.wait(lock, [] { return !ready; }); // 等待直到准备打印数字
        std::cout << ch << " ";
        ready = false; // 现在准备打印数字
        cv.notify_one();
    }
}

void printNumbers() {
    for (int i = 1; i <= 26; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [] { return ready; }); // 等待直到准备打印字母
        std::cout << i << " ";
        ready = true; // 现在准备打印字母
        cv.notify_one();
    }
}

int main() {
    std::thread t1(printLetters);
    std::thread t2(printNumbers);

    t1.join();
    t2.join();

    return 0;
}
```

- 协程：线程更换操作太重；用户端挂起就行。多用在高IO环境。

### go高并发的根本原因是大幅减少线程创建和销毁开销
### go奉行通过通信共享内存，而不是共享内存来通信

- go高并发的强大
	- 轻量级goroutine--高效创建与销毁线程
	- go的运行时使用协程进行更高效的调度
	- 简化并发模型---go  channel
	- 避免竞态条件---使用并发数据结构（并发队列，原子变量）与同步原语（互斥锁，等待组，原子操作等）
	- 标准库支持并发、强大社区多种框架

### M:N调度模型
- 问题：传统并发编程要考虑线程池大小、上下文切换。
- go将这些功能封装到了自己的运行时（runtime）进行智能管理。依旧是模拟并行

- M:N调度模型
	- goroutine通过m:n调度实现了对os线程的优化，也就是说一个os线程2mb可以存很多goroutine线程，而goroutine线程又通过协程管理，所以特别快，并且也特别小，2k左右。综合上述资料，讲一讲什么是m:n调度，n一定比m大或比m小吗？
	- M:N 调度是 Go 语言运行时（runtime）用于管理 Goroutines 和操作系统线程的一种机制。在这种调度模型中，M 代表 Goroutine 的数量，而 N 代表操作系统线程（OS threads）的数量。Go 运行时通过一个称为 Goroutine 调度器的组件来管理这些 Goroutines，它负责将 Goroutines 分配给可用的操作系统线程。

在 M:N 调度模型中，并不是所有的 Goroutine 都需要绑定到一个操作系统线程上。实际上，Go 运行时会在一个操作系统线程上执行多个 Goroutines，这允许它更有效地使用系统资源。每个操作系统线程可以看作是一个执行上下文，它可以执行多个 Goroutine，而不需要为每个 Goroutine 创建一个单独的操作系统线程。

这种调度方式的优势在于：

1. **资源优化**：操作系统线程通常比 Goroutine 更重量级，因为它们涉及到操作系统的调度和管理。通过在少量的操作系统线程上运行大量的 Goroutines，Go 运行时减少了内存占用和管理开销。

2. **性能提升**：Goroutine 之间的上下文切换比操作系统线程之间的上下文切换要快得多，因为 Goroutine 通常只需要保存和恢复少量的上下文信息。

3. **并发性**：Go 运行时可以根据系统的负载动态调整 Goroutines 的数量，从而在不同的系统和工作负载下提供更好的并发性能。

至于 N 是否一定比 M 大或小，这并没有固定的答案。在 Go 运行时中，N（操作系统线程的数量）通常比 M（Goroutines 的数量）小，这是因为 Go 运行时会尝试复用操作系统线程来执行多个 Goroutines。然而，根据程序的并发需求和系统资源，Go 运行时可能会动态地调整这两个数字。在某些情况下，如果程序的并发需求非常高，M 可能会大于 N，这时 Go 运行时可能会创建更多的操作系统线程来满足需求。在其他情况下，如果并发需求较低，N 可能会大于 M，这时 Go 运行时可能会减少操作系统线程的数量以节省资源。

总的来说，M:N 调度模型是 Go 语言高效管理并发的关键，它允许 Go 运行时在不同的系统和工作负载下灵活地调整资源使用，以提供最佳的性能和响应性。




## goroutine && runtime包
- go fun()    //创建一个goroutine

## channel实现数据传输——生产消费模型
- 不阻塞
- 阻塞



## sync提供并发安全的容器
[[go并发安全的容器]]