## =====基础部分====

### 1. 软连接和硬链接的区别
- 软链接有自己独立的inode和block，block中存放着源文件的路径，所以可以跨目录跨分区
- 硬连接没有独立的inode，而是将指针指向源文件在硬盘中的inode和block，源文件删除连接文件依然存在，所以不能跨分区和目录

### 2. 删除修改时间超过60分钟的.log格式的文件
find / -mmin +60 *.log| rm -f *

### 查看操作系统版本一般有三个命令：

　　1. lsb_release -a，适用于所有Linux发行版

　　2. cat /etc/redhat-release，适用于Redhat

　　3. cat /etc/os-release ，适用于所有Linux发行版

　　查看系统内核版本一般有两个命令：

  　　1. cat /proc/version
　　2. uname -a/-r
　　2. hostnamectl

### 3. 设置用户下次登录必须修改密码
chage -d 0 user01 
### 4. sudo和su的区别
- sudo: 用来提权，也就是其他用户以管理者的身份执行命令
- su：用来切换用户，一般情况下用su -username 带“-”参数可以将工作目录，环境变量一起切换过去

### 5. 配置dir目录下新建文件自动赋予user1用户的可读可写权限
umask 0177
### 6. 文件的特殊权限
- suid，只能用于可执行文件，开放文件所有者的权限给其他用户，即当用户执行该执行文件 时，会拥有该执行文件所有者的权限，例如passwd命令·
- sgid：可运用于文件或者目录，运用在文件的含义是开放文件所属组的权限给其他用户，即当用户执行 该执行文件时，会拥有该执行文件所属组用户的权限
- sbit：sbit权限只能运用于目录上，含义是该目录下所有的文件和子目录只能由所属者删除

### 7. 僵尸进程是如何产生的
- 子进程退出，父进程没有及时回收子进程的状态和释放子进程的资源

### 8. 系统平均负载的含义(top 命令第一行)
- 第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平 均值，数值越小意味着负载越低）。

### 9. kill传递的常用信号
kill -1	重载配置文件
kill -2 键盘终止
kill -3 键盘退出
kill -9 杀死进程
kill -15 终止进程
kill -18 继续
kill -19 停止
kill -20 暂停

### 10. RAID 0 1 5 的优缺点
- RAID0：将数据分散到几块硬盘上，读写速率翻倍，但是没有冗余，坏一块盘数据全丢
- RAID1：如有两张硬盘，数据会在两张硬盘里存放完全相同的数据，有冗余，任意坏一块盘不影响数据，但是读写速率只有一块盘
- RAID5：至少三块盘组成，通过奇偶校验的方式来做冗余，读写速率较低，但是冗余较高
- RAID10：先组成raid1，再有两个或多个raid1组成raid0
- RAID01：先组成raid0，再有两个或者多个raid0组成raid1

### 11. LVM中几个组件的关系(LV,PV,PE,VG)

- VG（卷组）：类似于非lvm系统中的物理磁盘，有一个或多个物理卷（pv）也就是相当于物理磁盘组
- LV（逻辑卷）：类似传统物理磁盘的分区，逻辑卷建立在卷组VG之上，LV逻辑卷可以建立文件系统并挂载
- PE（物理块）：每一个物理卷被划分为等同大小的若干个PE，组成物理卷的基本单元，大小可调，默认是4M
- PV（物理卷）：相当于物理硬盘，只不过是包含lvm相关管理定义的参数

### 12. iptables的四表五链
​	在linux操作系统中，Netfilter组件是集成在linux内核中扩展各种网络服务的结构化底层框架，提供内核级别的防火墙功能。内核中选取五个位置放了五个hook(勾子) ,就是我们所说的五链,function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则。
​	

- raw表:确认是否对该数据包进行状态跟踪
  - PREROUTING链: 再进行路由判断之前要进行的规则
  - OUTPUT链: 处理出站的数据包

- mangle表: 为数据包设定标记(比较少用)
  - PREROUTING链: 在进行路由判断之前要进行的规则
  - POSTTOUTING链: 在进行路由判断之后所要进行的规则
  - INPUT链: 处理入站的数据包
  - OUTPUT链: 处理出站的数据包
  - FORWARD链: 处理转发的数据包
- nat表: 修改数据包中的源,目的IP地址或者端口
  - PREROUTING链: 在进行路由判断之前要进行的规则
  - POSTTOUTING链: 在进行路由判断之后所要进行的规则
  - OUTPUT链: 处理出站的数据包
- filter表: 确认是否放行该数据包(过滤)
  - INPUT链: 处理入站的数据包
  - OUTPUT链: 处理出站的数据包
  - FORWARD链: 处理转发的数据包

### 13. SNAT与DNAT的区别
- 在数据包传递的过程中,修改了源地址或者端口,叫做SNAT,一般情况下，例如内网访问外网主机,会有网关或者防火墙来将来自内网的数据包的地址替换为自己的,来做到内网与外网之间的数据通信
- 在数据包传递的过程中,修改了目的地址或者端口,叫做DNAT,一般来说是外网无法直接访问内网,但是可以访问网关,网关或者防火墙就会把数据包的目的地址改为内网主句的地址,来做到外网访问内网的设备

### 14. selinux的作用 iptables，firewalld，neti，，，区别，各自工作在哪一层
- selinux的主要作用就是最大限度的减小系统服务进程能够访问到的资源,它通过对进程和文件资源采用MAC（强制访问控制方式）为Linux系统提供了改进的安全性。每个服务进程都有自己运行的特定区域,一般情况下无法访问其他进程和文件

### 15. cron计划任务的表达式(分时日月星期)
分 时 日 月 星期 执行的命令

### 16. bash中管道和重定向的作用
- 管道:接收前一条指令的正确返回结果作为下一条指令的参数输出,这要求后买的命令必须是可以接收前者传参的命令
- 重定向:重定向跟文件描述符有关系,用户可以自定义的文件描述符从3开始,而0,1,2代表这标准输入,输出,错误,012默认连接的都是终端,重定向可以更改输入输入的位置

### 17. 日志切割相关

### 18. Linux的目录结构和作用

![image-20220315090517816](E:\Blog_imgs\image-20220315090517816.png)

/bin：存放二进制文件，存放着常用的命令

/boot：存放启动Linux时候的一些核心文件，包括一些连接文件及系统镜像文件

/dev：设备的缩写，存放Linux的外部设备，如硬盘等

/etc：存放所有系统管理所需的配置文件，服务的默认配置文件等等

/home：普通用户的家目录

/root： 超级用户root的主目录

/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。

/sbin：这里存放的是系统管理员使用的系统管理程序

/tmp：用来存放一些临时文件

/usr：共享资源的意思，用户的很多应用程序和文件都存放再这个目录，跟windows上的program files有点类似

/var：该目录用于存放不断扩充的东西，一般日志的存放目录，和经常修改的文件

/mnt：临时挂载其他文件系统，例如U盘，光驱等等

/proc：进程的意思，是一种虚拟文件系统，存放当选内核中的一系列特殊文件，这个目录里面的内容不在硬盘，而在内存里面

### 19. Linux的启动过程

![image-20220315102608876](E:\Blog_imgs\image-20220315102608876.png)

https://www.cnblogs.com/codecc/p/boot.html

### 20. firewalld放行端口

```bash
# 开放端口
firewall-cmd --zone=public --add-port=端口/tcp --permanent
firewall-cmd --zone=public --add-port=端口/udp --permanent
# 开启端口转发
firewall-cmd --add-forward-port=port=本地端口:proto=tcp:toaddr=目的IP:toport=目的端口 --permanent
firewall-cmd --add-forward-port=port=本地端口:proto=udp:toaddr=目的IP:toport=目的端口 --permanent
# 禁用端口
firewall-cmd --zone=public --remove-port=端口/tcp --permanent
firewall-cmd --zone=public --remove-port=端口/udp --permanent
```

### Linux ctrl+c的原理

实际上是想程序发送`SIGINT`信号，强制程序的终止，同样可以使用kill -2，也称键盘交互退出

### TOP命令的原理

我觉得，Linux一切接文件，那么top命令也应该是从文件中读取的，像/proc目录下面就有进程，cup负载，内存相关的文件，我认为top中的有些内容可能是通过读取这些文件或者文件中某些参数的值来向用户呈现出来的



### 说说你使用过哪些Linux命令

要是问这个问题，大可刻意引导面试官，你可以说一些你非常熟悉的问题，大概率会问道说的这些命令

yum，ps，top，lsof，iptables，hostnamectl，passwd，useradd，groupadd，chmod，chown，ssh，paweroff，shutdown，reboot，等待，命令太多了

### cpu使用率会超过100%吗，为什么

会，因为每个核心的使用率是100%，多个核心加起来会超过100%



## ===网站服务===

### 1. FTP端口号，分别是什么作用
- 21和20
  - 21端口是控制连接
  - 20端口是数据连接

### 2. FTP主动模式和被动模式的区别
- 主动模式：客户端和服务端建立连接以后，客户端会向服务端发送port报文，表明自己监听的ip+端口，等待服务端20端口向我们发起连接
- 被动模式：客户端和服务端建立连接以后，客户端会向服务端发送pasv报文表明使用被动模式，服务端会把自己监听的端口发送给客户端，等待客户端建立连接
### 3. HTTP协议中常见状态码的作用(比如304是什么意思)

- 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
  - 1xx：指示信息--表示请求已接收，继续处理
  - 2xx：成功--表示请求已被成功接收、理解、接受
  - 3xx：重定向--要完成请求必须进行更进一步的操作
  - 4xx：客户端错误--请求有语法错误或请求无法实现
  - 5xx：服务器端错误--服务器未能实现合法的请求

```c
200 OK //客户端请求成功
400 Bad Request //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域
一起使用
403 Forbidden //服务器收到请求，但是拒绝提供服务
404 Not Found //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```

https://blog.csdn.net/xiaozhupiggg/article/details/6557121?utm_source=app&app_version=5.0.1&code=app_1562916241&uLinkId=usr1mkqgl919blen



### 4. HTTP端口号，HTTPS端口号
- 80，443
### 5. HTTPS/TLS的认证过程
- HTTPS不同于HTTP，在数据传输的过程中对数据完全加密，在TCP层之上又加了一层SSL层
	https://blog.csdn.net/ahou2468/article/details/108368246
### 6. POST和GET请求方式的区别
- 提交的过程
  - GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接
  - POST提交：把提交的数据放置在是HTTP包的包体中
- 传输数据的大小
  - 首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制
  - GET提交，特定浏览器和服务器对URL长度有限制
  - POST提交，由于不是通过URL传值，理论上数据不受限
- 安全性
  - POST的安全性要比GET的安全性高
  - 登录页面有可能被浏览器缓存，而缓存的是URL
  - 其他人查看浏览器的历史记录，那么别人就可以拿到你的账号和密码了
  - 使用GET提交数据还可能会造成Cross-site request forgery攻击

### 7. 什么是长连接，有什么作用
- 长连接，又称持久连接，用户建立的http连接，即使没有数据通信，也不会立马断开，而是有一个keepalive的超时时间，这样做可以减少建立连接时的资源开销
### 8. apache的mpm多路处理模块
- prefork：多进程I/O模型，一个主进程，管理多个子进程，一个子进程处理一个请求。 
- worker：复用的多进程I/O模型，多进程多线程，一个主进程，管理多个子进程，一个子进程管理 多个线程，每个线程处理一个请求
- event：它和 worker模式很像，最大的区别在 于，它解决了 keep-alive 场景下 ，长期被占用的线程的资源浪费问题。event MPM中，会有一个专门的线程来管理这些 keep-alive 类型的线程，当有真实请求过来的时候，将请求传 递给服务线程，执行完毕后，又允许它释放。这样，一个线程就能处理几个请求了，实现了异步非阻塞。

### 9. nginx的进程结构
- master-worker多进程工作模型

  一个或多个master带起多个worker进程，master进程用来监控worker的状态，接收外界指令等待，由worker来处理来处理用户的请求

### nginx如何实现高并发

https://blog.csdn.net/m0_38110132/article/details/75126316

### 10. rewrite的作用

- 我记得rewrite是可以实现这种url的跳转，域名跳转等等

### 11. select poll epoll的区别

1. select==>时间复杂度O(n)

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

2. poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.

3. epoll==>时间复杂度O(1)

epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）

- select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  

- epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现
  

### 12. 惊群效应是什么
- 一般情况下，在没有用户请求或者事件处理的时候，子进程worker会进入一个休眠状态，等待系统调用如（epoll_wait）,这时有一个用户向服务器发起了连接，内核在收到TCP的SYN包时，会激活所有的休眠worker子进程而只有一个或者几个worker可以建立连接，这样以来唤醒其他worker是没必要的，增加的系统开销

### 如何解决惊群问题

- Nginx 提供了一个 accept_mutex 这个东西，这是一个加在accept上的一把共享锁。即每个 worker 进程在执行 accept 之前都需要先获取锁，获取不到就放弃执行 accept()。有了这把锁之后，同一时刻，就只会有一个进程去 accpet()
- accept_mutex on; 默认 是on的状态。

### 13. 为什么要做动静分离

- 动静分离将网站静态资源（HTML，JavaScript，CSS，img 等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。
- 减轻后端服务器压力，提高静态资源访问速度：后端不用再将模板渲染为 html 返回给用户端，且静态服务器可以采用更为专业的技术提高静态资源的访问速度。

### 14. nginx的请求处理的过程

**Nginx作为服务器**

1. 启动
   - 首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址
   - 然后，nginx的master进程里面，先初始化好这个监控的socket（创建socket--设置addrreuse等选项--绑定到指定的ip地址端口--在listen），然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。
     此时，客户端就可以向nginx发起连接了。
   - 客户端向Nginx发起连接
2. 处理请求
   - 首先：当客户端与nginx进行三次握手，与nginx建立好一个连接后，此时，某一个子进程会accept成功，得到这个建立好的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。
   - 其次：设置读写事件处理函数并添加读写事件来与客户端进行数据的交互。
   - 最后，nginx或客户端来主动关掉连接。至此，一个连接寿终正寝。

**Nginx作为客户端**

​	Nginx也可以作为客户端来请求其他server的数据（如upstream模块），此时与其他server创建连接，所创建的连接也封装在ngx_connection_t结构体中。作为客户端：

- 首先：nginx获取一个ngx_connection_t结构体
- 然后，创建socket，并设置socket属性（比如非阻塞）
- 之后，通过添加读写事件，调用connect/read/write来调用连接
- 最后，关掉连接，释放ngx_connection_t。

### 15. Nginx与Apache如何选择
https://haicoder.net/note/nginx-interview/nginx-interview-redis-expire.html

### 16. http的处理动作

1. 建立连接：接收或拒绝连接请求
2. 接收请求：接收客户端请求报文中对某资源的一次请求的过程
3. 处理请求：服务器对请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理
       元数据：请求报文首部
       <method> <URL> <VERSION>
       HEADERS格式name:value
       <request body>
       示例：
       Host: www.chuyuni.cn   请求的主机名称
       Server: Apache/2.4.7
   HTTP常用请求方式，MethodGET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS
4. 访问资源：服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源
           资源放置于本地文件系统特定的路径：DocRoot
           DocRoot → /var/www/html
           /var/www/html/images/logo.jpg
           http://www.magedu.com/images/logo.jpg
       web服务器资源路径映射方式：
       (a) docroot        (b) alias
       (c) 虚拟主机docroot(d) 用户家目录docroot

5. 构建响应报文：一旦Web服务器识别除了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体
       1）响应实体：如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。响应报文中通常包括：描述了响应主体MIME类型的Content-Type首部描述了响应主体长度的Content-Length实际报文的主体内容
       2）URL重定向：web服务构建的响应并非客户端请求的资源，而是资源另外一个访问路径
       永久重定向：http://www.360buy.com
       临时重定向：http://www.taobao.com
       3）MIME类型：Web服务器要负责确定响应主体的MIME类型。多种配置服务器的方法可将MIME类型与资源管理起来魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名时显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型类型协商：有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)"最好"

6. 发送响应报文：Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了

7. 记录日志：最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务


## ===mysql===

### 如何远程登录数据库

`grant all privileges on *.* to root@'%' indentfied by 'password'`

给远程用户进行授权 然后远程用户通过数据库所在的服务器的IP地址来远程连接（远程用户需要安装客户端工具）

### MySQL的explain

​	用来查询sql语句是否使用索引，是否做全表扫面等等

​	expain返回的字段10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra

**概要描述：**
id:选择标识符
select_type:表示查询的类型。
table:输出结果集的表
partitions:匹配的分区
type:表示表的连接类型
possible_keys:表示查询时，可能使用的索引
key:表示实际使用的索引
key_len:索引字段的长度
ref:列与索引的比较
rows:扫描出的行数(估算的行数)
filtered:按表条件过滤的行百分比
Extra:执行情况的描述和说明

### 1. mysql服务结构，当客户端发起请求之后，mysqld如何处理
- MySQL是一个典型的c/s服务结构，mysqld是mysql的后台守护程序，当客户端通过socket或者TCP连接数据库的时候，由mysqld（mysql服务器进程），来处理用户发起的DDL，DCL,DML,DQL语句，来对数据库进行操作，连接层用于处理用户连接，用来跟SQL层进行交互，SQL层负责解析连接层传来的指令
- 并交由存储引擎层来进行读写查询等操作
  - DDL：数据定义语言		用来创建库或者表
  - DCL：数据控制语言		用来针对权限进行控制 grant
  - DML：数据操作语言		操作表中的数据	insert插入，update更新，delete删除
  - DQL：数据查询语言		查询表中的数据	select
### 2. 如何重置mysql密码(多种方法)
- 用户密码设置

```bash
- UPDATE user SET password=PASSWORD("new password") WHERE user='username';
- SET PASSWORD FOR username=PASSWORD('new password');
- mysqladmin -u root "old password" "new password"
```

- 忘记root密码

```bash
- service mysqld stop
- mysqld_safe --skip-grant-tables --skip-networking &
```

### 3. 索引的作用
- 索引相当于目录的作用，当DQL语句进行查询操作的时候，查询索引比直接遍历目录所消耗的资源小的多，常见的索引类型由b+树索引，hash索引，全文索引等等
- 添加索引的方式，**alter,create index**等等

### 索引的种类

- B+树索引
- HASH索引
- 全文索引
- R树索引

### 4. b树和b+树的区别

- B树
  - 每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。
- B+树
  - 只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针

![image-20220228124022829](E:\Blog_imgs\image-20220228124022829.png)

### 5. 什么情况下会导致索引失效
- 索引有自我维护的能力。
- 对于表内容变化比较频繁的情况下，有可能会出现索引失效。
- 重建索引就可以解决

### 6. innodb和myisam存储引擎的区别
1. 在事务上:myisam不支持事务，innodb支持事务
2. myisam使用了表级锁，innodb使用了行级锁
3. mysql5.0后面的版本默认使用innodb引擎，5.0之前都是用myisam引擎
4. InnoDB支持外键，而MyISAM不支持 
5. InnoDB不支持全文索引，而MyISAM支持
6. myisam查询效率更高，支持全文索引。innodb不支持全文索引，查询效率差myisam6-7倍
7. innodb数据如（迁移备份等等，不如myisam）

### 7. 如何客户的数据库是myisam如何切换到innodb(大致步骤)
- 使用mysqldump来对数据库进行全备，替换库表空间文件的myisam为innodb，通过备份文件重新恢复数据库
### 8. mysql服务损坏，且没有备份的情况下，数据库服务如何恢复
1. 一般情况下，像企业中使用mysql会开启binlog二进制日志，该日志会记录数据库中发生的所有操作，可以通过binlog日志来恢复到指定的位置
2. 或者直接拷走数据库存放目录，在另一台新的机器上面使用copy过来的配置文件和data重新拉起一个数据库

### 9. 事务的作用
- 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。事务为了防止操作数据库的某一个环节失败而导致数据出现问题，所以事务要么成功，要么全部取消

### 10. 事务的ACID
- 事务具有原子性，一致性，隔离性和持久性
  - 原子性：所有语句作为一个单元只能全部执行成功或者全部取消
  - 一致性：如果数据库在事务开始时处于一致性，则在执行该事务期间保持一致状态
  - 隔离性：事务之间不相互影响
  - 持久性：事务成功完成后，所有的更改都会记录在数据库中，

### 11. 事务的隔离级别
- 我了解的是有四种隔离级别
  - RU（独立提交）：隔离性最差，允许事务查看其他事务还未提交的更改
  - RC：允许事务查看其他事务已提交的更改
  - RR：innodb的默认级别，确保每个事务的select输出一致
  - SERIALIZABLE：将一个事务的结果与其他事务完全隔离

### 脏读，幻读，不可重复读



### 12. 悲观锁与乐观锁的区别
- 事务中的锁和隔离级别一起体现事务的“i”隔离性
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁
- 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，乐观锁适用于多读的应用类型，这样可以提高吞吐量

### 13. 事务的redo和undo的过程
- redo: 当对事务中对数据操作的时候，会先将数据读取在内存中，将更改的结果写入redo_buffer中，当事务结束的commet的时候，再将redo_buffer的内容写入硬盘的redo_log中，完成对数据的操作，体现事务的持久性
- undo: 是"回滚日志"，事务日志中的一种，再操作数据的时候，undo也会拿去一份数据用于回滚，体现事务的原子性，全部执行或者回滚到事务开始的位置

### 14. 在事务未提交的情况下，数据库服务器重启，会发生什么
- 由于undo的存在,数据库会回到事务开始的状态

### 15. 二进制日志中row模式和statement模式的优缺点
- statement模式：记录内容就是sql语句，容易看懂，记录时不需要太多的磁盘空间，但是记录的不够严谨
- row模式：记录的更加严谨，但是占用较多的磁盘空间，而且可读性较差

### 16. 慢查询日志分析(mysqldumpslow)
- 将MySQL服务器中，影响数据库性能的相关sql语句记录在日志文件中，方便改进以提高数据库的性能

### 17. 主从复制原理(课上画图分析过，几个要素binlog,dump thread,relay-log,master.info,io thread,sql thread)
- 主库必须开启binlog日志，从库不用开启binlog，dump线程会检测主库binlog中的变化，
- 并将这种变化通过从库的IO进程传递给从库并且记录master.info也就是同步的状态位置，
- 然后relay-log存储IO线程接收的记录，SQL线程再读取relay-log里面的记录同步主库的操作
- 并且产生一个relay.info的文件，记录relay-log的状态位置从而完成主从复制

### 主从存在的问题

1. 主库宕机，必定导致服务停顿，因为需要人为讲服务切到从库上
2. 从库数据与主库不同步，因为dump线程和IO线程之间是异步的方式，如果从库落后于主库，这时主库宕机，将丢失从库还未同步完成的数据，解决方法就是半同步复制

### 18. 主从复制，从库误操作写入数据怎么办(主从不同步，会导致SQL线程停止)
- 从库可以选择跳过这条记录，以完成和主库同步，可以手动跳过，我记得好像也可以在配置文件里指定

### 19. 主从复制，从库IO线程故障排查思路
- 可能出现的错误
  - 如网络不同,像从库于主库断开连接,主库宕机等等
  - 请求binlog失败,无法从主库那边获取binlog
  - 操作的对象已存在(create),或者操作的对象不存在(update,insert等等)
  - 从库的SQL线程出现问题等等
- 解决思路,停止从库的同步,找出问题,恢复从库,再恢复与主库的同步

### 20. 主从复制中的延时从库，半同步复制，过滤复制使用场景
- 正常的主从结构存在一定的问题,如数据操作量大的时候,从库的同步跟不上主库,或者说不能保障主库所做的操作,从库一定可以完成
- MySQL从大概5.5还是5.7以后是开始支持半同步复制,传统的主从都是异步的,主库是不管从库的处理进度的,如果从库的进度落后于主库。而这是主库又宕机,会导致从库的数据相较于主库是不完整的,半同步复制则一定程度上加入了一点同步的特点,保证提交的事务已经传给了至少一个备库。
- 过滤复制则是设有黑白名单,主从同的时候只同步再定义的黑白名单规则中的库或者是表
### 21. MHA架构的原理
- MHA能够在较短的时间内实现自动故障检测和故障转移，
- 当Master出现故障时，它可以自动将最新数据的Slave提升为新的Master,然后将所有其他的Slave重新指向新的Master

### 22. MySql双主架构

**MySQL双主（主主）架构方案思路是:**

1. 两台mysql都可读写，互为主备，默认只使用一台（masterA）负责数据的写入，另一台（masterB）备用；

2. masterA是masterB的主库，masterB又是masterA的主库，它们互为主从；

3. 两台主库之间做高可用,可以采用keepalived等方案（使用VIP对外提供服务）；

4. 所有提供服务的从服务器与masterB进行主从同步（双主多从）;

5. 建议采用高可用策略的时候，masterA或masterB均不因宕机恢复后而抢占VIP（非抢占模式）；

​	这样做可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；

**但是也有几个不足的地方:**

1. masterB可能会一直处于空闲状态（可以用它当从库，负责部分查询）；

2. 主库后面提供服务的从库要等masterB先同步完了数据后才能去masterB上去同步数据，这样可能会造成一定程度的同步延时；

**架构的简易图如下:**

![image-20220315105607400](E:\Blog_imgs\image-20220315105607400.png)



### 主主架构的一致性问题

https://blog.csdn.net/sunsscode/article/details/108047560

## 	====mongodb====
1. 关系型和非关系型数据库的区别
2. mongodb的优势有哪些
3. 什么是mongodb中的document
4. 什么场景下会使用mongodb
5. mongodb中的切片是什么意思
6. 如何将数据分布在不同的chunk上
7. mongodb支持哪些类型的索引
8. 副本集有哪些角色，是做什么的
9. 副本集的主节点选举原则


## ====redis====
### 1. 什么是CDN
- CDN称为内容分发网络，单节点的网络架构，会导致距离较远的用户访问速度较慢，所以采用多台缓存服务器，分布到各个IDC机房，当用户发起访问的时候，数据就会由距离用户最近的缓存服务器发给用户，达到加快访问速度的问题

### CDN如何选择离用户最近的服务器提供服务

1. 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS 系统会最终将域名的解析权交给 [CNAME](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/CNAME_record) 指向的 CDN 专用 DNS 服务器。
2. CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。
3. 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。
4. CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
5. 基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址：
6. 根据用户 IP 地址，判断哪一台服务器距用户最近；
7. 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；
8. 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。
9. 全局负载均衡设备把服务器的 IP 地址返回给用户。
10. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

DNS 服务器根据用户 IP 地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用 CDN 服务的网站，只需将其域名解析权交给 CDN 的全局负载均衡（GSLB）设备，将需要分发的内容注入 CDN，就可以实现内容加速了。



https://zhuanlan.zhihu.com/p/113037678

### 2. 关系型和非关系型数据库的区别
- 关系型数据库是由二维表及其之间的联系所组成的一个数据组织

  - 优点：
    1、易于维护：都是使用表结构，格式一致；
    2、使用方便：SQL语言通用，可用于复杂查询；
    3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。
  - 缺点：
    1、读写性能比较差，尤其是海量数据的高效率读写；
    2、固定的表结构，灵活度稍欠；
    3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈
- 非关系型数据库应该是一种数据结构化存储方法的集合，可以是文档或者键值对等

  - 优点：
    1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。
    2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；
    3、高扩展性；
    4、成本低：nosql数据库部署简单，基本都是开源软件。

  - 缺点：
    1、不提供sql支持，学习和使用成本较高；
    2、无事务处理；
    3、数据结构相对复杂，复杂查询方面稍欠。

3. redis是单线程还是多线程

- 单线程

### 3. buffer 与 cache

- buffer：缓冲也叫写缓冲，一般用于写操作，可以将数据先写入内存再写入磁盘，buffer 一般用于写缓冲，用于解决不同介质的速度不一致的缓冲，先将数据临时写入到里自己最近的地方，以提高写入速度，CPU 会把数据先写到内存的磁盘缓冲区，然后就认为数据已经写入完成看，然后由内核在后续的时间再写入磁盘，所以服务器突然断电会丢失内存中的部分数据。
- cache：缓存也叫读缓存，一般用于读操作，CPU 读文件从内存读，如果内存没有就先从硬盘读到内存再读到CPU，将需要频繁读取的数据放在里自己最近的缓存区域，下次读取的时候即可快速读取。

### 5. Redis内存淘汰机制
- 如果缓存中的数据永久存在，那占用的内存就会变得越来越大。而内存是有限的，所以缓存系统需要在需要的时候删除一些不必要的缓存数据以节约内存空间。Redis 提供了两种机制配合来达到上述目的：过期策略 和内存淘汰机制。
- Redis 在使用内存达到某个阈值（通过 maxmemory 配置)的时候，就会触发内存淘汰机制，选取一些 KEY 来删除。

### 6. Redis数据持久化RDB与AOF
- RDB 持久化是通过快照的方式，即在指定的时间间隔内将内存中的数据集快照写入磁盘。在创建快照之后，用户可以备份该快照，可以将快照复制到其他服务器以创建相同数据的服务器副本，或者在重启服务器后恢复数据。RDB 是 Redis 默认的持久化方式。
- AOF 持久化会把被执行的写命令写到 AOF 文件的末尾，记录数据的变化。默认情况下，Redis 是没有开启 AOF 持久化的，开启后，每执行一条更改 Redis 数据的命令，都会把该命令追加到 AOF 文件中，这是会降低 Redis 的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高 AOF 的性能。

### 7. 什么是Redis事务
- 是将命令队列化，加入到执行队列中，也就是说redis 事务就是一次性、顺序性的执行一个队列中的一系列命令。

### 8. Redis为什么这么快
- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；数据结构简单，对数据操作也简单
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

### 9. redis主从复制原理
- 跟MySQL的主从一样，也是为了解决数据备份而存在的

  - slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 host 和 ip ，但是复制流程没开始。

  - slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 ping 命令给 master node。

  - 如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。

9. Redis Sentinel的作用
10. Redis Sentinel原理
11. Redis Cluster优缺点
12. AOF rewrite原理
13. AOF触发机制

### redis的底层原理





### redis和MySQL的区别

实际上说就是关系型数据库和非关系型数据库之间的区别

## ===负载均衡===
### 什么是负载均衡

负载均衡就是客户端发来的请求，由多台后端服务器共同处理，避免单台服务器负载过大的导致服务宕机停顿的问题

### 1. 正向代理与反向代理区别

- 代理对象不同：正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端，反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端。

### 介绍一下LVS

​	**LVS（Linux Virtual Server）**即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，整个集群对用户而言都是透明的。根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式

### keepalived+nginx、keepalived+lvs、keepalived+haproxy各自的优缺点适应的场景

https://www.jianshu.com/p/117262703af1

### 2. Nginx负载均衡常见算法
1. 轮询：按时间顺序逐一分配到不同的后端服务器(默认)
2. weight：加权轮询,weight值越大,分配到的访问几率越高
3. ip_hash：每个请求按访问IP的hash结果分配,这样来自同一IP的固定访问一个后端服务器
4. url_hash：按照访问URL的hash结果来分配请求,是每个URL定向到同一个后端服务器
5. least_conn 最少链接数,那个机器链接数少就分发

### 3. session、cookie、token的区别

- Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤,比如加密后的账户名密码等信息

- session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。

- Token是作为一种身份验证存在的

  基于Token的身份验证的过程如下:

  1. 用户通过用户名和密码发送请求。
  2. 程序验证。
  3. 程序返回一个签名的token 给客户端。
  4. 客户端储存token,并且每次用于每次发送请求。
  5. 服务端验证token并返回数据。

### 4. 四层和七层负载均衡的区别

​	所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。七层的负载均衡，就是在四层的基础上（**没有四层是绝对不可能有七层的**），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。


### 5. vrrp的原理
​	VRRP协议是一种容错的主备模式的协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代替出现故障的路由器进行工作，通过VRRP可以在网络发生故障时透明的进行设备切换而不影响主机之间的，主路由通过选举算法产生数据通信。

### 6. keepalived脑裂故障的原因
​	由于某些原因，导致两台keepalived高可用服务器在指定时间内，无法检测到对方的心跳，即都认为自己应该是master，各自取得资源及服务的所有权

- 原因：
  	1、服务器网线松动等网络故障
  	2、服务器硬件故障发生损坏现象而崩溃
  	3、主备都开启firewalld防火墙

### 7. LVS的几个工作模式
- **NAT：**将数据的源地址或者目的地址进行转换，来达到数据包的传递
- **TUN：**请求数据包发往虚拟服务器，然后虚拟服务器根据数据包的报头查看数据包的请求地址，并修改源地址和目的地址，然后通多调度算法，将数据包发往一个真是服务器处理，然后由真实服务器修改源地址为vip，目的地址为直接发往请求方
- **DR：**请求数据包发往虚拟服务器，然后虚拟服务器更具请求数据包的包头，然后通过调度算法，选择一个真是服务器，并通过MAC地址发送数据包给真实服务器，这使得虚拟服务器和真实服务器必须在同一个区域，然后由真实服务器发给请求方





### 8. 容灾和备份的区别(数据中心常见面试题)
### 9. 两地三中心解决方案是什么(数据中心常见面试题)
### 10. rto和rpo是指的什么(数据中心常见面试题)
### 11. LVS常用调度算法(区分静态算法与动态算法来枚举)
### 12. 如何解决负载均衡器成为瓶颈的问题？


## =====文本三剑客====
### 1. sed将文件test中第50行中的helloworld改为nihao？

`sed -i '50c nihao' test`

### 2. 打印/etc/passwd的奇数行？

`sed -n 'p;n' /etc/passwd`

`sed -n '1~2p' /etc/passwd`

偶数行：

`sed -n 'n;p' /etc/passwd`

`sed -n '0~2p' /etc/passwd`

### 3. 在每一行后增加一空行？

`sed G /etc/passwd`

前面加：

`sed '{x;p;x}' /etc/passwd`

### 4. 打印Linux系统的"IP地址,系统版本,CPU核心,内存大小"



### 5. 在文本的所有行前加序号

`sed '=' test | sed 'N;s/\n/: /'`

### 6. 统计某个文件夹下的文件占用的字节数

`ll | awk 'BEGIN {size=0} {size=size+$5} END{print "size is ",size}'`

### 7. 从第4个字符开始，截取10个长度字符串

## =====shell脚本编程====
### 1. 打印乘法口诀表

### 2. 晚上11点到早上8点之间每两个小时输出一次系统日期与时间
### 3. 找出系统内大于50k，小于100k的文件，并复制到/tmp目录下
### 4. 每隔2秒检查一下系统是否存在top进程，如果存在，就杀死
### 5. 测试192.168.1.0/24网段中主机存活情况(ping检查)，把存活的主机写入host.txt

## ====监控====

### Prometheus

#### 1. 为什么要使用监控

​	为了避免业务不停顿，如果不是人去24小时盯着的话，最好的解决方案就是把服务主机监控起来，实时监测其状态，并通知管理人员	

#### 2. Prometheus的组件、架构

**架构：**

​	Prometheus主要由Prometheus Server、Pushgateway、Job/Exporter、Service Discovery、Alertmanager、Dashboard这6个核心模块构成。

![image-20220228002306099](E:\Blog_imgs\image-20220228002306099.png)

- **Prometheus Server**：是Prometheus组件中的核心部分，可以独立部署在服务器上、或者docker容器等，它可以直接从监控目标或者间接通过推送网关来拉去监控指标。并且汇总和记录收集到的监控数据，存储为时间序列数据。可以外提供数据查询（promQL），告警等管理。
- **Exporter**：将监控数据采集的端点通过HTTP服务的形式暴露给Prometheus Server，Prometheus Server通过访问该Exporter提供的Endpoint端点，即可获取到需要采集的监控数据。目前大多常用的组件或者服务都有相应的Exporter。例如nginx，mysql，Linux系统信息等等。
- **Pushgeteway：**是用于支持短期或者批量计划任务的汇聚节点。或者将内部网络中的监控数据主动push到Gateway上。然后由Promertheus server通过pull的方式去拉取Gateway上的数据。
- **AlertManager：**主要用于Prometheus服务端发送的告警信息，并且也支持很多丰富的告警方式。
- **Service Discovery：**可以理解为动态发现，例如kubernetes等环境或者服务内建了对Prometheus的支持。这时候Prometheus可以通过例如API的方式去动态的发现待监控的服务。

#### 3. 有哪些指标类型

常见的或者核心的指标以下几种：

- 计数器    #只增不减特性
- 仪表盘    
- 直方图 
- 摘要

#### 4. Prometheus的优点

- 本身具备数据查询语言PromQL
- 对存储条件依赖性较小，本身具备TSDB时序数据库来存储数据
- 监控数据可以通过HTTP协议主动拉取，也可以通过Gateway进行汇总和推送
- 可通过静态配置文件或者服务发现来监控目标

适用于以机器为中心的监控，同样也适用于面向服务的动态监控。同时Server与被监控的主机或者服务之间也是相互独立的。Prometheus server可以独立的部署而不依赖于其他远程措施。

#### 5. Prometheus 的局限性

1.更多地展示的是趋势性的监控
Prometheus作为一个基于度量的系统，不适合存储事件或者日志等，它更多地展示的是趋势性的监控。如果用户需要数据的精准性，可以考虑ELK或其他日志架构。另外，APM更适用于链路追踪的场景。

2.Prometheus本地存储不适合大量历史数据存储
Prometheus认为只有最近的监控数据才有查询的需要，所有Prometheus本地存储的设计初衷只是保存短期（如一个月）的数据，不会针对大量的历史数据进行存储。如果需要历史数据，则建议使用Prometheus的远端存储，如OpenTSDB、M3DB等。

#### 6. prometheus如何采集数据的

1. 侵入式埋点监控（直接采集），通过在客户端集成，如果Kubernetes API直接通过引入Prometheus go client，提供/metrics接口查询kubernetes API各种指标；这一类Exporter直接内置了对Prometheus监控的支持，比如cAdvisor，Kubernetes，Etcd，Gokit等，都直接内置了用于向Prometheus暴露监控数据的端点。

2. 通过exporter方式（间接采集），在外部将原来各种中间件的监控支持转化为Prometheus的监控数据格式，如redis exporter将Reids指标转化为Prometheus能够识别的HTTP请求；间接采集，原有监控目标并不直接支持Prometheus，因此我们需要通过Prometheus提供的Client Library编写该监控目标的监控采集程序。例如： Mysql Exporter，JMX Exporter，Consul Exporter等。

#### 7. prometheus数据如何展示和告警





### Zabbix

#### 1. 滴滴夜莺(n9e)架构及与zabbix，prometheus的对比

https://blog.csdn.net/weixin_43876361/article/details/110873861

​	夜莺是从**采集、存储、监控、告警判断、告警通知、告警自愈**都开源出来了，换句话说就是：**开箱即用**，直接采集交换机/虚机/应用指标，出现异常直接通知到**钉钉/企微/邮箱**。

​	夜莺是Go开发的，所有组件编译后均是二进制文件，无须安装其他依赖，后端只需要上述九个夜莺模块的二级制包，加上mysql，redis，nginx三个组件，就可以轻松在公司上落地监控。

#### 2. zabbix有哪些组件，是做什么的

- zabbix_server：监控的核心组件，他负责接收客户端发来的报告信息，所以配置，统计等等操作
- zabbix_database：所有收集的信息都存放在数据库里面
- zabbix_proxy：当监控的主机数量多的时候，他可以代理一部分server的功能，减轻server的负载
- zabbix_agent：客户端软件，用来采集各项数据，并把数据传输给server

#### 3. snmp的作用与使用的端口号

​	SNMP（Simple Network Management Protocol，简单网络管理协议）用来管理设备的一些信息，获取设备的运行信息，可以检测服务器设备的性能硬件等等

#### 4. zabbix监控项，监控指标，怎么持久化

### ....

####  prometheus和zabbix的区别

https://www.cnblogs.com/xiaoyuxixi/p/12235979.html




## ====ansible====
### 1. Ansible是什么？原理是什么
​	是一款基于Python开发的自动化运维工具，Ansible是基于模块工作的，本身没有批量部署的能力。用SSH进行传输，真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。

**原理：**将模块或者命令生成对应的临时py，并通过ssh将脚本传输到远程主机，然后赋予执行权限，执行并返回结果，然后删除临时py文件，并且sleep0结束该进程

### 2. 什么是 Ansible 模块？常用模块
https://blog.csdn.net/qq_34646546/article/details/86606408

模块是ansible部署服务的依据，对远程主机部署服务的时候，需要使用相应的模块及其参数

常见的模块有:user,group,copy,file,service,shell,commend,ping,yum等等，可以单独使用这些模块，也可以写进playbook剧本，使远程主机按照剧本上的规定去执行



### 3. ansible使用copy模块来将/opt/aa.txt复制到/home/jack中

ansible -m copy -a "src=/opt/aa.txt dest=/home/jack/" hosts

### 4. 简述Ansible ad-hoc和playbook的区别？
https://blog.csdn.net/JackLiu16/article/details/79521724

### 5. Ansible如何实现任务的循环

通过**with_items**定义字典列表或者字符串列表的，让模块的参数的值从列表中读取，这样就只需要定义好我们的列表就可以了

### 6. Ansible hanlder的作用

​	handlers是一种触发器，它可以对task进行监控，如果task所指定的任务状态发生变化，也就是状态时changer，则进行notify通知，然后触发handlers所定义的操作，如果task中所在指定的任务状态是ok的时候，则不通知notify执行handlers的所定义的操作

​	例如：playbook中定义修改apache的配置文件，然后重启httpd，但是有由于幂等性，第二次执行该playbook，则会发现配置文件不需要修改，状态返回ok，但是重启的操作照样会被执行，所以说通过handlers监控指定操作的状态，如果发生改变，则通过notify通知handlers执行handlers定义的操作

### 7. Ansible角色的作用

​	严格来说，角色应该是对ansible使用的一种规范，如果说做一些简单的事情，比如让远程主机下载httpd，只需要在playbook中使用yum模块并且指定主机，就可以达到下载的目的，但是如果加入模板，配置文件，网页文件等文件，这样就会变的很乱，不宜解读和管理，所以官方制定了一套规范，也就是角色，规定目录结构，这样角色和角色之间能有很好的隔离作用，互不影响，各司其职


## ====python====
### 1. python的垃圾回收机制

​	在C/C++中采用**用户自己管理维护内存**的方式。自己管理内存极其自由，可以任意申请内存，但也为大量内存泄露、悬空指针等bug埋下隐患。
​	因此在现在的高级语言（java、C#等）都采用了垃圾收集机制。python也采用了垃圾收集机制。

**引用计数器为主，分代码回收和标记清楚为辅**

**引用计数器机制**：当一个对象，有新的引用时候，他引用计数器就会增加，反之，当引用他的对象被删除的时候，引用计数器就会减少，当引用计数为0的时候，就意味着该对象的生命周期结束了

https://foofish.net/python-gc.html

### 2. python中可迭代的与迭代器的区别

- 迭代器
  - 迭代时访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完。迭代器只能前进不会后退

- 可迭代对象
  - list，tuple，str等数据类型可以使用for...in...循环语句的方法依次拿出数据进行使用，这样访问数据的方法称之为遍历，也叫**迭代**
  - 但是，不是所有的数据类型都可以使用循环语句的方法遍历访问，所以，可以被迭代的数据类型，称之为**可迭代对象**

### 3. 迭代与递归的区别

- **递归**（recursion）：递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）

- **迭代**（iteration）：重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）

- ____iter____函数与____next____函数[#](https://www.cnblogs.com/echoooo/p/15806158.html#____iter____函数与____next____函数)

  **迭代器遵循迭代器协议：必须拥有iter方法和next方法**

### 4. 什么是闭包

​	内部函数包含对外部作用域而非全局作用域变量的引用，该内部函数被称为**闭包函数**

### 5. 装饰器的作用

​	让其他函数在不需要做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。

​	装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等

### 6. 面向对象的三个特性(封装，继承，多态)

### 7. 排序算法(重点看冒泡，插入，快速这三个，最好能默写)

https://blog.csdn.net/weixin_45876097/article/details/120760101

- 快速排序

```python
def quick_sort(demo):
    if len(demo) > 1:  
    # 当列表长度大于1时进行排序
        mid = demo[len(demo) // 2]
        # 选取基准元素，此例选取中间值作为基准元素
        left, right = [], [] 
        # 初始化基准元素左右两侧为空列表
        demo.remove(mid)
        # 将基准元素从原列表中移除
        for i in demo:
        # 依次遍历列表元素，小于基准元素的值放到left列表中，大于基准元素的值放到right列表中
            left.append(i) if i < mid else right.append(i)
        return quick_sort(left) + [mid] + quick_sort(right)
        # 返回排序后的列表
    else:
        return demo
        # 递归结束条件为待排序列表仅有一个元素
test_list = [0,9,2,5,3,6,1]
test_list = quick_sort(test_list)
print(test_list)
[0, 1, 2, 3, 5, 6, 9]  # 输出顺序列表
```

- 选择排序：

```
def select_sort(demo):
    for i in range(len(demo)-1):
    # i表示需要选择的轮数
        min_index = i
        # min_index表示筛选出最小元素的索引
        for j in range(i+1,len(demo)): 
        # j表示每次进行比较的元素索引
            if demo[j]<demo[min_index]:
            # 当待比较元素j比已知最小元素小时最小元素的索引更新为j
                min_index = j
        if min_index != i:
        # 经过一轮比较后如果最小元素索引发生改变，则使最小元素与起始位置元素进行交换
            demo[i],demo[min_index] = demo[min_index],demo[i]
    print(demo)
test_list = [0,9,2,5,3,6,1]
select_sort(test_list)
[0, 1, 2, 3, 5, 6, 9]  # 输出顺序列表
```

- 插入排序：

```
def insert_sort(demo):
    for i in range(1,len(demo)):
    # i表示需执行插入的轮数
        for j in range(i,0,-1): 
        # j表示需要进行比较的元素索引，从已排序列表的后方开始比较
            if demo[j]<demo[j-1]:
                demo[j],demo[j-1] = demo[j-1],demo[j]
            else:
                break
            print(demo)
    print(demo)
test_list = [0,9,2,5,3,6,1]
insert_sort(test_list)
[0, 1, 2, 3, 5, 6, 9]  # 输出顺序列表
```

- 冒泡排序：

```
def bubble_sort(demo):
    for i in range(1, len(demo)):
    # i表示冒泡的轮数
        for j in range(0,len(demo)-i):
        # j表示每次比较的元素索引
            if demo[j]>demo[j+1]:
            # 当索引小的元素大于索引大的元素时进行交换
                demo[j],demo[j+1] = demo[j+1],demo[j]
    print(demo)
test_list = [0,9,2,5,3,6,1]
bubble_sort(test_list)
[0, 1, 2, 3, 5, 6, 9]  # 输出顺序列表
```

### python常见模块

- **OS模块**

python的标准库中的os模块主要涉及普遍的操作系统功能，如：

```python
os.sep 可以取代操作系统特定的路径分割符。 
os.name字符串指示你正在使用的平台。比如对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'。 
os.getcwd()函数得到当前工作目录，即当前Python脚本工作的目录路径。 
os.getenv()和os.putenv()函数分别用来读取和设置环境变量。 
os.listdir()返回指定目录下的所有文件和目录名。 
os.remove()函数用来删除一个文件。 
os.system()函数用来运行shell命令。
os.linesep字符串给出当前平台使用的行终止符。
os.path.split()函数返回一个路径的目录名和文件名。
os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。
os.path.exists()函数用来检验给出的路径是否真地存在
os和os.path模块
os.listdir(dirname)：列出dirname下的目录和文件
os.getcwd()：获得当前工作目录
os.curdir:返回但前目录（'.')
os.chdir(dirname):改变工作目录到dirname
os.path.isdir(name):判断name是不是一个目录，name不是目录就返回false
os.path.isfile(name):判断name是不是一个文件，不存在name也返回false
os.path.exists(name):判断是否存在文件或目录name
os.path.getsize(name):获得文件大小，如果name是目录返回0L
os.path.abspath(name):获得绝对路径
os.path.normpath(path):规范path字符串形式
os.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）
os.path.splitext():分离文件名与扩展名
os.path.join(path,name):连接目录与文件名或目录
os.path.basename(path):返回文件名
os.path.dirname(path):返回文件路径
```

- **sys模块**

sys模块可以实现从程序外部向程序内部传递参数，如：

```
sys.argv: 实现从程序外部向程序传递参数。
sys.exit([arg]): 程序中间的退出，arg=0为正常退出。
sys.getdefaultencoding(): 获取系统当前编码，一般默认为ascii。
sys.setdefaultencoding(): 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding('utf8')，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）
sys.getfilesystemencoding(): 获取文件系统使用编码方式，Windows下返回'mbcs'，mac下返回'utf-8'.
sys.path: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。
sys.platform: 获取当前系统平台。
sys.stdin,sys.stdout,sys.stderr stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们 
sys._getframe()
```

- **paltform模块**

paltform模块可以获取系统的一些信息，如：

```
platform.system() 获取操作系统类型，windows、linux等
platform.platform() 获取操作系统，Darwin-9.8.0-i386-32bit
platform.version() 获取系统版本信息 6.2.0
```

### 8. CPU进程调度算法
### 9. 进程、线程和协程的区别

进程是资源分配的最小单位，而线程是由进程创建的，也是cpu调度的最小单位，线程不拥有资源，而是访问进程的资源，线程不能脱离进程独立存在，一旦进程中止，线程也会全部中止，协程可以理解为一种特殊的线程，比线程更加轻量，协程不受内核控制，是运行在用户空间的，由程序直接控制，协程占用更小的资源，上下文切换更快

### 10. 同步与异步，阻塞与非阻塞

同步：

异步：

阻塞：

非阻塞：

### 11. 通信中tcp粘包问题如何产生与解决
### 12. 深拷贝与浅拷贝的区别

### 13. 什么是序列化和非序列化
### 14. 元组，列表，字典的区别，判断是否可迭代

**元组 tuple**[#](https://www.cnblogs.com/echoooo/p/15806158.html#元组-tuple)

​	元组被称为只读列表，即数据可以被查询，但是不可以被修改

​	元组其实不可变的是其地址空间，如果地址空间里存的是可变的数据类型的话，就比如列表就是可变的

**列表 list**[#](https://www.cnblogs.com/echoooo/p/15806158.html#列表-list)

​	列表相对于字符串，不仅可与存储不同的数据类型，而且可以存储大量的数据，而且列表是有序的，有索引值，并且list是可变数据类型，可以进行增删改查等操作

**字典 dict**[#](https://www.cnblogs.com/echoooo/p/15806158.html#字典-dict)

​	字典是一种映射类型，采用键值对(key-value)的形式存储数据。python对key进行哈希函数运算，而key必须是可哈希的。可哈希表示key必须是不可变类型，如：数组，字符串，元组

**集合 set**[#](https://www.cnblogs.com/echoooo/p/15806158.html#集合-set)

​	集合是**无序**的，**不重复**，**确定性**的数据集合，它里面的元素是可哈希的(不可变类型)，但是集合本身是不 可哈希（所以集合做不了字典的键）的。以下是集合最重要的两点：

- 去重，把一个列表变成集合，就自动去重了
- 关系测试，测试两组数据之间的交集，差集，并集等关系

### 15. python中lambda函数的作用是什么
### 16. 简述flask MVC框架



## ====虚拟化与存储=====
### 1. CPU指令环ring0 ring3的作用

​	在CPU的所有指令中，划分指令的特权级别，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。Intel的CPU将特权级别分为4个级别：RING0,RING1,RING2,RING3。Windows只使用其中的两个级别RING0和RING3，RING0只给操作系统用，RING3谁都能用。如果普通应用程序企图执行RING0指令，则Windows会显示“非法指令”错误信息

### 2. 内存虚拟化影子页表的作用
### 3. CPU虚拟化技术(VT-x)是什么
### 4. vlan与vxlan的区别
### 5. OpenStack核心组件有哪些
### 6. 简述Ceph节点的角色？
### 7. 文件级存储，块级存储，对象存储区别

1. 块级概念：块级是指以扇区为基础，一个或我连续的扇区组成一个块，也叫物理块。它是在文件系统与块设备（例如：磁盘驱动器）之间。
   典型设备：磁盘阵列，硬盘，虚拟硬盘

2. 文件级概念：文件级是指文件系统，单个文件可能由于一个或多个逻辑块组成，且逻辑块之间是不连续分布。逻辑块大于或等于物理块整数倍
   典型设备：FTP、NFS服务器，SamBa

3. 对象存储概念：对象存储（Object-based Storage）是一种新的网络存储架构，基于对象存储技术的设备就是对象存储设备（Object-based Storage Device）简称OSD。
   典型设备：内置大容量硬盘的分布式服务器

https://www.cnblogs.com/machong/p/13164391.html

## ====docker&k8s====

### Docker

#### 1. Docker与虚拟机有何不同

- 虚拟机实现资源隔离的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等实现的。简单的来说，就是需要虚拟出硬件资源，这无疑增大了资源的开销
- 容器技术严格来说并不是虚拟化，没有客户机操作系统，是共享内核的。容器可以视为软件供应链的集装箱，能够把应用需要的运行环境、缓存环境、数据库环境等等封装起来，以最简洁的方式支持应用运行，轻装上阵，当然是性能更佳

#### 2. Docker容器有几种状态

- created：已经被创建 （使用 docker ps -a 命令可以列出）但是还没有被启动 （使用 docker ps 命令还无法列出）
- running：运行中
- paused：容器的进程被暂停了
- restarting：容器的进程正在重启过程中
- exited：上图中的 stopped 状态，表示容器之前运行过但是现在处于停止状态（要区别于 created 状态，它是指一个新创出的尚未运行过的容器）。可以通过 start 命令使其重新进入 running 状态
- destroyed：容器被删除了，再也不存在了

#### 3.docker三大组件

- 镜像，容器，仓库
- 简单来说，docker镜像，就是一系列应用，服务打包封装好的用户空间，也可以理解为容器运行的一种静态模板，容器是镜像的运行实例，用户通过镜像创建容器的时候，就是将这种打包好的用户空间独立运行与内核之上，仓库就是存放或者分发镜像的地方，有公有仓库，私有仓库等等

https://blog.csdn.net/qq_39408435/article/details/109754834?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-109754834.pc_agg_new_rank&utm_term=%E5%AF%B9docker%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%90%86%E8%A7%A3&spm=1000.2123.3001.4430

#### 4. Dockerfile中的命令COPY和ADD命令有什么区别

- Dockerfile中的COPY指令和ADD指令都可以将主机上的资源复制或加入到容器镜像中，都是在构建镜像的过程中完成的
- COPY指令只能从执行docker build所在的主机上读取资源并复制到镜像中。而ADD指令还支持通过URL从远程服务器读取资源并复制到镜像中。并且ADD指令可以解压上传的压缩包问文件

####  5. 简述联合文件系统(UnionFS),简述merged，upperdir，lowerdir作用

联合文件系统是一种分层堆叠的文件系统，依赖于其他文件系统之上

我们的基础层称为**lowerdir**即原始文件所在的位置。

客户端所做的任何修改都将反映在“**upperdir**”层上：

- 如果更改文件，新版本将写入其中（file1）。
- 如果删除文件，将在该层上创建一个删除标记（file2）。
- 创建一个新文件（file4）。

最后，“**merged**”是所有层合并后的最终视图。

#### 6. Docker核心技术实现原理(可以参考：https://t.hk.uy/aPmF)

http://dockone.io/article/2941

#### 7. dockerfile中的cmd和run的区别

RUN 指令：用于指定 docker build 过程中要运行的命令。

- 例如：RUN yum install iproute nginx && yum clean all

CMD 指令：

1. CMD 指令：类似于 RUN 指令，用于运行程序，但二者运行的时间点不同；CMD 在docker run 时运行，而非docker build;
2. CMD 指令的首要目的在于为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束；
3. CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。

#### docker的优缺点

https://www.cnblogs.com/fuhuabeihou/p/11534670.html

### Kubernetes

#### 1. k8s的组件

**控制平面（master）：**

- **kube-apiserver：**Api-server负责输出kubernetes API。它是操作集群所有命令的接入点，并且负责接收、校验并响应所有的REST请求。结果状态被持久存储在etcd中。可以理解为Api-server是整个集群的网关。
- **etcd：**k8s集群的所有状态信息都需要持久存储于etcd中。etcd是一种分布式键值存储，可用于服务发现，共享配置等。etcd作为一个独立的服务组件，不属于k8s集群本身。
- **kube-controller-manager：**在k8s中，集群中的大多数功能是通过控制器的进程执行实现的，这些控制器进程被集成于kube-controller-manager守护进程中。
- **kube-scheduler：**例如当api server确认pod对象的创建请求之后，便需要由scheduler根据集群内各节点可用的资源情况，以及要运行的pod的资源需求进行调度决策。

**工作平面（Node）：**

- **kubelet**是工作于工作节点上的守护进程，它从api server接受关于pod对象的配置信息并确保它们处于期望的状态。kubelet会在api server上注册当前的工作节点。并且汇报节点情况。
- **kubeproxy：**每个工作节点都需要运行一个kube-proxy守护进程，它能够按需为service资源对象生成iptables或者IPVS规则。从而捕获当前service的数据流量并转发到正确的pod上。
- **容器运行时环境：**每个node都需要具备容器运行时环境，如docker、podman。来负责下载镜像运行容器等等。

#### 2. k8s创建一个pod的流程

1. 用户通过kubectl或其他api客户端提交pod spec给api server 
2. api server尝试着将pod对象的相关信息存入etcd中，待写入操作执行完成，api server即会返回确 认信息至客户端 
3. api server开始反应etcd中的状态变化 
4. 所有的kubernetes组件均使用watch机制来跟踪检查api server上的相关的变动 
5. kube-scheduler（调度器）通过其watcher觉察到api server创建了新的pod对象但尚未绑定至任 何工作节点 
6. kube-scheduler为pod对象挑选一个工作节点并将结果信息更新至api server 
7. 调度结果信息由api server更新至etcd存储系统中，而却api server也开始反映此pod对象的调度结 果
8. pod被调度到的目标工作节点上的kubelet尝试在当前节点上调用docker启动容器，并将容器的结 果状态回送至api server 
9. api server将pod状态信息存入etcd中 
10. 在etcd确认写入操作成功完成之后，api server将确认信息发送至相关的kubelet事件将通过它被接收

#### 3. k8s的存储方案有那些

- EmptyDir
- HostPath
- NFS
- PV/PVC

#### 4. k8s控制器有哪些

- **ReplicationController：**比较原始的pod控制器，已经被废弃，由ReplicaSet替代 

- **ReplicaSet：**保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级 
- **Deployment：**通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本 
- **HPA：**可以根据集群负载自动水平调整Pod的数量，实现削峰填谷 
- DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务 
- Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务 
- Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行

## ====网络====
### NAT

网络地址转换

### DNS

域名解析服务，将域名解析成对应的ip地址来进行访问

https://www.cnblogs.com/echoooo/p/15889195.html

dns的过程

### DHCP

动态主机配置协议，是局域网的网络协议

![image-20220228031535760](E:\Blog_imgs\image-20220228031535760.png)

https://zhuanlan.zhihu.com/p/71357927

https://www.cnblogs.com/echoooo/p/15889186.html

### OSPF

开放最短路径优先 

https://zhuanlan.zhihu.com/p/41341540

### RIP

动态路由协议

### rip和ospf的关系与区别

1. 名称不同：
   - RIP（路由信息协议）：是一种分布式基于距离向量的路由选择协议；
   - OSPF（开放式最短路劲优先协议）：使用分布式基于链路状态的路由选择协议
2. 工作核心不同：
   - RIP：到达目的路由的跳数
   - OSPF：计算链路的度量值
3. 接收方不同：
   - RIP：仅和相邻路由交换信息
   - OSPF：向自治系统内所有的路由器发送消息
4. 发送内容不同：
   - RIP：交换自己的路由表
   - OSPF：发送的信息是与本路由器相邻的所有路由器的链路状态，只涉及与相邻路由器的连通状态

链路状态

### 单臂路由

### OSI七层，TCP四层

https://www.cnblogs.com/echoooo/p/15967896.html

### TCP三次握手四次挥手

https://www.cnblogs.com/echoooo/p/15796535.html

### 网址栏里输入URL发生了什么

**基本步骤：**

1. DNS域名解析;

   浏览器缓存——本地hosts文件——本地dns——根DNS

2. 建立TCP连接；(三次握手四次挥手)
3. 发送HTTP请求；
4. 服务器处理请求；
5. 返回响应结果；
6. 关闭TCP连接；
7. 浏览器解析HTML；
8. 浏览器布局渲染；

https://www.cnblogs.com/xiaoxin-test/p/13559905.html



### BGP和RIP的区别

https://blog.csdn.net/weixin_34280237/article/details/91677702

## ====往年面经收集=======

### top命令中的load average：0.00，0.01，0.05这三个数字代表什么

三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低

### kill USR1和USR2信号的区别，还了解过什么信号

USR1通常被用来告知应用程序重载配置文件；例如，向Apache HTTP服务器发送一个

**USR1信号将导致以下步骤的发生：**停止接受新的连接，等待当前连接停止，重新载入配置文件，重新打开日志文件，重启服务器，从而实现相对平滑的不关机的更改。

**USR2：平滑升级**，对于nginx来说，发送USR2信号给master进程，这个时候，会重新起一个master进程还有对应的worker进程，后续连接请求将由信的master和worker去处理，然后给就旧的master发送一个QUIT信号，让他处理完旧的请求以后自行退出

### 如何查看服务响应时间，响应过慢应该怎么办

**查看服务响应时间**

1. `curl -o /dev/test -s -w %{time_namelookup}::%{time_connect}::%{time_starttransfer}::%{time_total}::%{speed_download}"\n" "http://www.baidu.com" `

2. httping工具

**响应过慢排查思路：**

1. 检查系统负载，内存，cpu，磁盘的使用情况以及日志有无异常输出
2. 检查网络是否正常，如dns解析，带宽，网络吞吐量（iptraf工具）等等
3. 检查应用程序有无异常，是否正常运行，是否存在错误日志
4. 请求的资源是否加载过慢，如视频图片等资源
5. 如果涉及数据库相关，可以查看是否存在慢日志等

### 网站压力测试工具ab，测试时关心哪些数据，如何判断已过载

https://www.cnblogs.com/zhuchenglin/p/8066557.html

**Requests per second: 19.66 [#/sec] (mean)**
//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值
**Time per request: 5087.180 [ms] (mean)**
//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值
**Time per request: 50.872 [ms] (mean, across all concurrent requests)**
//服务器平均请求处理时间，大家最关心的指标之三

### http和https的区别在于

​	HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，而HTTPS协议，简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

​	HTTPS和HTTP的区别主要如下：

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### https的原理

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 

　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

　　（5）Web服务器利用自己的私钥解密出会话密钥。

　　（6）Web服务器利用会话密钥加密与客户端之间的通信。

[<img src="https://s4.ax1x.com/2022/03/05/bwG51s.png" alt="bwG51s.png"  />](https://imgtu.com/i/bwG51s)

**https在验证证书的环节使用的是非对称加密，在数据传输环节使用的是对称加密**

### tcp如何保证其可靠性

tcp主要是通过**校验和**，**序列号，确认应答，超时重传，连接管理，流量控制，拥塞控制**来保证数据传输的可靠性

具体如下：

https://blog.csdn.net/xuzhangze/article/details/80490362

https://zhuanlan.zhihu.com/p/112317245

### 进程之间怎么通信

进程之间的通信方式一共有一下几种：

- **管道：命名管道，匿名管道**
- **信号**
- **信号量**
- **消息队列**
- **共享内存**
- **socket**

**管道：**管道只能单向流动，双向需要简历两个管道

- **匿名管道：**只能在父子关系的进程中使用
- **命名管道：**可以在没有关联的两个进程之间使用，因为他创建了一个类似管道的设备文件，使用这个设备文件就可以通信

**信号：**信号是进程之间唯一的异步通信机制，主要是通过键盘输入和软件命令，比如利用kill pid，可以停止进程

**信号量：**是一个计数器，控制多个进程对资源的访问，通常作为一种锁机制，防止多个进程去访问或者修改资源

**消息队列：**消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

**共享内存：**就是映射一段能被共享的内存，这段内存是由一个进程创建，但是多个进程都可以共享，是最快的一种进程间通信的方式（不需要从用户态到内核态的切换）

**socket：**socket套接字，不仅仅可以用于本地进程通信，还可以用于不同主机进程之间的通信

https://blog.csdn.net/a718515028/article/details/108385942

### 线程之间怎么通信



### 对称加密和非对称加密

**对称加密**：加密和解密使用的相同的密钥，是将原始数据通过密钥加密后顺带密钥一起发给对方，对方使用该密钥对加密数据进行解密

- 对称加密由于加解密都用同一个密钥，所以传输速度快，但是因为私钥再网络里传输，所以安全性较低

**非对称加密**：非对称加密加密和解密使用的不是相同的密钥，当请求网络资源的时候，自己会生成一把公钥一把私钥，将公钥发给对方，对方收到后，使用公钥将数据加密以后发回来，这时我们用自己的私钥去对信息进行解密得到原文

- 安全性相对较高，只需要发自己的公钥给对方就可以了，不需要将私钥发出去，这大大提高了对数据的安全性，但是对应的处理速度就略微慢一点

### 请求和响应报文头部常见的属性

**常见的请求头部报属性**：

- Accept：告诉服务端，客户端收到上面类型的响应
- Referer：表示这是请求时从哪个URL进来的，比如在百度搜索关键字，然后跳转对应的网站，这时候Referer就是`www.baidu.com`
- Cache-Control：对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，可以同个该属性进行设置
- Accept-Encoding：告诉服务端能接收什么编码格式，包括字符编码，压缩形式
- Host：指定请求资源所在的主机和端口
- User-Agent：告诉服务器客户端使用的操作系统，浏览器版本和名称等等

**常见响应头部报文属性：**

- Cache-Control：应输出到客户端后,服务端通过该属性告诉客户端该怎么控制响应内容的缓存
- ETag：表示你请求的资源的版本，如果该资源发生改变，那么这个属性也会跟着变化
- Location：在重定向中或者创建资源时使用
- Set-Cookie：服务端可以设置客户端的cookie

### 静态缓存资源如何知道上面时候该更新

​	在HTTP响应头部报文中，由一个ETag属性，该属性是检测资源的版本，再次访问同一个资源，服务器就根据这些参数检查这些资源是否修改，没修改就返回304状态码，并返回一个空的响应体，浏览器直接读取本地的缓存得到数据。

### 进程运行级别

- 1 ：单用户模式

- 2 ：多用户字符界面（不支持网络）

- 3 ：多用户字符界面（支持网络）服务器默认的运行级别

- 4 ：未定义

- 5 ：图形界面

- 6：重启

https://www.cnblogs.com/zhouhbing/p/4457766.html

### Linux是如何操作内存的

### BGP和RIP的区别

![image-20220308141615205](E:\Blog_imgs\image-20220308141615205.png)

### 内网组网的网段选择

实则考察子网掩码的**网络位**和**主机位**的划分

### TCP/UDP的区别

​	**TCP**是一种面向有链接的，可靠的传输层通信协议，想要通过tcp来进行数据传递，必须通过三次握手建立tcp连接以后，才可以开始传输数据，数据传输完成以后，通过四次挥手断开连接

​	**UDP**是一种无连接是传输层通信协议，UDP传输数据的时候，不会建立连接，也就是不会去管对方有没有收到，所以也说UDP协议是不可靠的，像DNS就是使用UDP协议，他的好处是速度比较快



### shell跟其他语言有什么区别

​	**shell语言**是充当了用户和内核之间的翻译官的角色，提供了用户和内核交互的接口，他是接收用户输入的命令然后共给内核去执行，再呈现内核返回过来的执行结果

shell具有**头文件，**指定使用哪个shell来执行，定义变量的时候可以不指定类型，取变量的时候需要加$符号，赋值等号左右不可以有空格，而且语句结束以后不需要像C语言用`；`结尾，使用if语句的时候，要用fi来结尾，中间的循环体跟其他语言一样，并无太大的差别，然后执行的时候需要给脚本添加执行权限，可以`bash filename`，也可以通过`./`的形式去执行

### nginx正向代理和反向代理的区别

nginx正向代理：比如我们访问国外的网站，像谷歌之类的，我们没办法直接访问，不过可以找一台可以访问谷歌的服务器在对我们的数据包进行一个转发，对谷歌来说，只有代理服务器和谷歌之间的数据通信，客户端对谷歌来说是隐藏的

nginx反向代理：当我们访问服务端的时候，代理服务器帮助我们做转发，代理服务器于服务端属于同一个区域，像frp这种内网内网穿透技术就类似于反向代理，我们可以通过代理服务器去访问内网的设备

https://blog.csdn.net/a3192048/article/details/89737337



### 二层交换机和三层交换机的区别

**二层交换机**工作OSI模型的二层（数据链路层），可以识别数据包中的MAC地址信息，根据MAC地址进行转发

**三层交换**（也称多层交换技术，或IP交换技术）是相对于传统交换概念而提出的。传统的交换技术是在OSI网络标准模型中的第二层——数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。简单地说，三层交换技术就是：二层交换技术＋三层转发技术。也可以说三层交换机是带有路由功能的交换机





### 如何部署lnmp架构

1. 在Linux上安装nginx（yum，二进制，编译），编写nginx的配置文件，启动nginx服务
2. 部署MySQL，二进制方式安装MySQL（下载MySQL的二进制包，解压二进制包，启动mysql，初始化数据库，创建用户）
3. 部署php动态解析服务，通过yum安装php，在网站根目录下写入或者拉去php文件，比如常见的探针，访问检查nginx与php的连通性
4. 创建搭建网站所需要的库，create database blog，在更目录放入或者拉去网站源码
5. 访问网站，填写数据库相关信息，完成搭建



### 如何监控10万台服务器的状态（基本思路）

1. 首先是网络的问题，如果是大内网环境，做好对主机内网ip的划分和记录，如果是公网，做好主机host的解析（也是为了后续能更方便的使用ansible来批量部署和管理）
2. 部署zabbix监控，通过ansible来在所有被监控主机上安装ansible-agent，这里可以选择主动监控，让被监控主机主动将采集到的数据传给监控端
3. 优化告警，由于监控主机数量多，对告警的筛选和阈值的控制做进一步的精确的控制和优化，防止处理大量告警邮件而造成的开销
4. 采集方面，使用zabbix-proxy代理，分担zabbix-server的处理数据的压力
5. 数据库方面，单独分离数据库到另一台服务器，使用主从结构，存储采集数据



### golang比python火的原因

https://zhuanlan.zhihu.com/p/355644408







### cpu的软中断和硬中断



### 运维是干什么的

我觉得运维就是，将未上线项目部署上线，对以上线项目进行调优，对正在运行的项目保障稳定（高可用）可靠（容错）



### 什么是高可用

就是减少业务停顿时间，尽可能保证业务不间断的运行，并且提供一定的容错措施，简单来说就是确保服务的质量，比如我们通常测试网络连通性，可能会去ping baidu.com，如果不通，就是本地网络存在问题，而不会考虑是baidu提供的服务出现问题，这就是高可用的一种表现



### 如何查看系统负载，怎么判断负载很高，负载很高怎么办

- 查看系统负载

```bash
[root@server ~]# w
[root@server ~]# uptime
[root@server ~]# top
[root@server ~]# cat /proc/loadavg
[root@server ~]# vmstat
```

- 判断系统负载过高

```bash
load average: 0.01, 0.09, 0.07
# 这三个值分别是1分钟，5分钟和15分钟的平均负载，一般看15分钟的平均负载，一般情况下平均负载超过cpu的核心数，则判定为负载较高
```

- 负载过高的解决方法

```bash
# 使用top命令，查看进程对cup和内存的占用情况，判断有无异常进程，配合ps命令和kill命令处理异常进程
# 查看孤儿进程，僵尸进程等异常进程
# 优化服务器的性能，例如增加使用多核心高主频的cpu或者增加cpu的数量等等
```



