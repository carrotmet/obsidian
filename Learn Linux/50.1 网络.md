1.TCP/IP和OSI
- 联系：都有网络层，传输层，应用层。osi向上将应用层拆分，进行更细粒度的流量控制（会话和表示。用来定义更细粒度的鉴权和传输数据类型控制）。soi向下将数据接口层拆为数据链路和物理层。提高数据传输独立性。osi利用独立的数据链路层进行数据帧的校对。而tcpip依赖网络接口层的一部分进行数据校验，独立性较差。

2.一个url从输入到页面展示发生了什么
- url包括三个部分：协议，域名，资源路径。
- 首先会对户名进行dns解析，这是一个循环解析过程，会从本地循环到根域名解析器直到找到。
- 然后建立TCP连接，进行三次握手（http/1.x）

- 如果使用https协议，则在tcp连接建立后，要再进行TLS握手，
	- 首先浏览器发送一个加密套件给服务器
	- 服务器进行证书返回
	- 浏览器进行证书验证并生成随机数用于会话加密
	- 结束握手开始构建http数据包

- 浏览器将构建一个http请求消息通过tcp发送给服务器
- 服务器接到消息按资源路径和查询参数定位资源
- 处理信息后，返回一个http响应效益，包括状态码，响应头，响应体
- 如果非持久连接，则会关闭tcp连接。
- 最后浏览器按照返回的**状态码**和内容进行渲染。

3.请求报文和响应报文结构
- 请求包含
	- 请求行：get、post、put、delete（方法，资源路径，版本）
	- 请求头：附加信息——各种参数
	- 请求体：一些方法携带：post、put
- 响应包含
	- 响应码：200,403，404，500（版本，响应码，响应消息）
	- 响应头：长度、缓存、cookie
	- 响应体：html，图片，json

4.http1.1 1.1 2.0 3.0 主要区别
- 1.0：无连接，无状态（默认tcp短连接，队头阻塞（连接必须一个一个完成））
	- 没有host域，不支持虚拟主机
	- 不支持断点续传，每次要传送全部页面和数据
	- 引入了If-Modified-Since和Expires等头部用于缓存控制。
- 1.1：无状态，明文传输。安全性差，默认长连接（等待时间）
	- 因为长连接，所以发消息不必阻塞，可以管道通信。并发多个请求。但响应依旧会队头阻塞
	- 分快传输编码：因为·持久连接需要预知单个数据包大小，方便做返回分割。当不知数据包大小的时候，就要分块传输（加上编码告诉服务端是某次数据包的第几个部分）
	- 新增请求方法和状态码
- 1.0：无状态，短连接，不支持虚拟主机，不支持断点续传，有缓存控制
- 1.1无状态，长连接，有host头支持虚拟主机，长连接管道传输避免传输的头部阻塞，长连接可以分块传输，新增请求方法和状态码
- 2.0 创新的帧结构是并行的基础。以单位流作为一个请求和返回的唯一标识。两者结合实现并行传输，多路复用。通过头部压缩和服务端推送进一步提升效率
![[Pasted image 20240708023031.png]]

- 2.0
	- 二进制分帧：所有数据需要格式化和反格式化，提高解析效率，是并行的前提
	- 流控制：一个请求和响应的数据包，称为一个数据流。有流id，进行流控制
	- 多路复用：允许并行交错的请求和响应（一个tcp连接里）
	- 头部压缩hpack：压缩请求和响应头部，减少冗余
	- server push 服务端推送内容到本地，可以从用户本地加载资源
	- 通过hpack压缩和流控制，实现多路复用。因为服务端可以根据流id进行组装返回


5.常用方法和状态码
- get（获取）
	- 幂等获取
	- 获取用户id，返回一个每次一样的静态资源
	- 安全的，不改变资源状态
- post（请求）
	- 不幂等请求
	- 密码判断，验证码判断

1.1新增
- put（更新）
	- 整体替换
	- 幂等更新（替换了全部资源）
- patch（更新）
	- 部分更新
	- 不幂等
	- 返回一组指令描述如何修改现有资源
	- 有body
	- ![[Pasted image 20240708031543.png]]
- delete（删除）
	- 幂等

2  成功
- 200 ok
- 204 成功，没返回
- 206 部分返回

3 重定向
- 301 永久重定向
- 302 临时重定向
- 303 应使用get，因为这个url不能重定向访问
- 304 条件不符合

4 客户端错误
- 400  bad request报文语法错误
- 401  unauthorized 需要认证或认证失败
- 403 fobidden  拒绝
- 404 no fiound  找不到

5 服务端错误
- 500 执行错误
- 503 超负荷或停机

6.get和post，缓存在哪里？
- 区别
	- 定义 获取 请求
	- 幂等性  等  不等
	- 请求体  无 有
	- 安全性 高  低
	- 长度限制 有(本来无，但浏览器有限制)  无
	- 缓存 有  无
- 缓存
![[Pasted image 20240708033347.png]]
- 缓存的存储位置和持续时间受多种因素影响，包括HTTP缓存头（如`Expires`、`ETag`、`Last-Modified`等）、服务端配置、代理和CDN设置、以及客户端的缓存策略。正确配置和使用缓存可以显著提高Web应用的性能和用户体验。

7. tcp和udp区别
- 一对一，需要建立连接，有确定和重传机制保证数据完整，可以控制速率，阻塞。但开销大（序列号，确定号，窗口大小），效率低；
- 一对多，可广播不建立连接，不保证数据包顺序，可靠，不补救。开销小，只要端口和链路层校验、但效率高，
- 都用socket封装实现。

8. tcp如何确保可靠性
- 头尾数据校验，序列号，确定码（超时重传），阻塞，三次握手，有序传输
- 三次握手
	- 客户端发一个syn
	- 服务端返回syn+ack（ack用来表示服务端连接确认）
	- 客户端返回一个ack（确认syn）
- 为什么三次
	- 四次浪费，两次不能保证是新的请求
- 四次挥手
	- 客户端发一个fin
	- 服务端回一个ack，表示收到
	- 服务端发送所有返回后，发送一个fin，表示要结束了
	- 客户端回一个ack，表示收到。
	- 服务端收到后断开连接
- [一篇文章帮你拿下面试八股文之网络三次握手四次挥手， HTTP超文本传输协议重点理论刨析到实现简单的HTTP服务, 思考着图解着学习网络 (咱不死记硬背)_三次握手 四次挥手 八股文-CSDN博客](https://blog.csdn.net/weixin_53695360/article/details/123189672)

9. keep-alive，缓存（cdn，cookie，session），dns
- heepkeep-alive持久连接（复用一个tcp），tcp的keepalive是保持活力的机制（超时关闭判准）
- cookie、seesion（秘钥，状态信息（是否在线））
	- cookie存在用户端，是秘钥的缓存；session存在服务器端，是状态信息
	- cookie有4k限制，session'理论没限制
	- cookie相对容易被篡改，需要定期刷新，加密
	- cookie可以设置过期时间，session只在会话保持时存在（状态信息）
- 缓存
	- 服务端缓存——redis：冷启动、分担压力
	- 用户端缓存——cookie
	- CDN 组网。一组数据中心，做公网的负载均衡,比如FR5的3DNS就是
	- 浏览器缓存、nginx缓存
- dns
	- 客户端查询，本地dns缓存，递归到根和顶级
	- 一般用114DNS解析


